"""Foundation types for MultiSplit widget.

Pure Python types with no Qt dependencies.
All types are JSON-serializable and immutable where appropriate.
"""

from __future__ import annotations
from dataclasses import dataclass
from enum import Enum
from typing import NewType, Optional, Any
import uuid


# Type aliases
PaneId = NewType('PaneId', str)


class Orientation(str, Enum):
    """Split orientation."""
    HORIZONTAL = "horizontal"
    VERTICAL = "vertical"


class WherePosition(str, Enum):
    """Positions for pane placement operations."""
    REPLACE = "replace"
    LEFT = "left"
    RIGHT = "right"
    TOP = "top"
    BOTTOM = "bottom"

    def to_orientation(self) -> Optional[Orientation]:
        """Convert position to split orientation."""
        if self in (WherePosition.LEFT, WherePosition.RIGHT):
            return Orientation.HORIZONTAL
        elif self in (WherePosition.TOP, WherePosition.BOTTOM):
            return Orientation.VERTICAL
        return None  # REPLACE has no orientation


class Direction(str, Enum):
    """Cardinal directions for focus navigation."""
    LEFT = "left"
    RIGHT = "right"
    UP = "up"
    DOWN = "down"

    def to_where_position(self) -> WherePosition:
        """Convert direction to where position for splits."""
        return WherePosition(self.value)


# Custom exceptions
class PaneError(Exception):
    """Base exception for pane operations."""
    pass


class PaneNotFoundError(PaneError):
    """Raised when a pane ID is not found in the tree."""
    def __init__(self, pane_id: PaneId):
        self.pane_id = pane_id
        super().__init__(f"Pane not found: {pane_id}")


class InvalidStructureError(PaneError):
    """Raised when tree structure is invalid."""
    pass


class InvalidRatioError(PaneError):
    """Raised when split ratios are invalid."""
    def __init__(self, ratios: list[float], message: str = ""):
        self.ratios = ratios
        msg = f"Invalid ratios: {ratios}"
        if message:
            msg += f" - {message}"
        super().__init__(msg)


class WidgetProviderError(PaneError):
    """Raised when widget provider fails."""
    def __init__(self, widget_id: str, message: str = ""):
        self.widget_id = widget_id
        msg = f"Widget provider failed for: {widget_id}"
        if message:
            msg += f" - {message}"
        super().__init__(msg)


class CommandExecutionError(PaneError):
    """Raised when a command fails to execute."""
    pass


# Utility functions
def generate_pane_id() -> PaneId:
    """Generate a unique pane ID."""
    return PaneId(str(uuid.uuid4())[:8])


def validate_ratio(ratio: float) -> None:
    """Validate a single ratio value."""
    if not 0.0 < ratio < 1.0:
        raise InvalidRatioError([ratio], "Ratio must be between 0 and 1")


def validate_ratios(ratios: list[float]) -> None:
    """Validate a list of split ratios."""
    if len(ratios) < 2:
        raise InvalidRatioError(ratios, "At least 2 ratios required")

    total = sum(ratios)
    if abs(total - 1.0) > 0.001:  # Allow small floating point errors
        raise InvalidRatioError(ratios, f"Ratios must sum to 1.0, got {total}")

    for ratio in ratios:
        if ratio <= 0:
            raise InvalidRatioError(ratios, f"All ratios must be positive, got {ratio}")


def normalize_ratios(ratios: list[float]) -> list[float]:
    """Normalize ratios to sum to 1.0."""
    total = sum(ratios)
    if total == 0:
        # Equal distribution if all zeros
        return [1.0 / len(ratios)] * len(ratios)
    return [r / total for r in ratios]


@dataclass(frozen=True)
class Size:
    """Immutable size representation."""
    width: int
    height: int

    def __post_init__(self):
        if self.width < 0 or self.height < 0:
            raise ValueError(f"Size dimensions must be non-negative: {self.width}x{self.height}")


@dataclass(frozen=True)
class Position:
    """Immutable position representation."""
    x: int
    y: int


@dataclass(frozen=True)
class Rect:
    """Immutable rectangle representation."""
    position: Position
    size: Size

    @property
    def x(self) -> int:
        return self.position.x

    @property
    def y(self) -> int:
        return self.position.y

    @property
    def width(self) -> int:
        return self.size.width

    @property
    def height(self) -> int:
        return self.size.height