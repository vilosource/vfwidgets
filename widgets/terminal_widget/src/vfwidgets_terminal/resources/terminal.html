<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VFWidgets Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Local dependencies -->
    <link rel="stylesheet" href="/static/css/xterm.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: monospace;
            background: #1e1e1e;
            overflow: hidden;
        }

        #terminal {
            width: 100vw;
            height: 100vh;
            padding: 4px;
        }

        /* Custom scrollbar styling */
        .xterm-viewport::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .xterm-viewport::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        .xterm-viewport::-webkit-scrollbar-thumb {
            background: #464647;
            border-radius: 5px;
        }

        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: #5a5a5c;
        }

        /* Firefox scrollbar */
        .xterm-viewport {
            scrollbar-width: thin;
            scrollbar-color: #464647 #1e1e1e;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4d4d4;
            font-size: 14px;
        }

        .loading.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>
    <div id="loading" class="loading hidden">Connecting to terminal...</div>

    <!-- Local scripts -->
    <script src="/static/js/xterm.js"></script>
    <script src="/static/js/xterm-addon-fit.js"></script>
    <script src="/static/js/xterm-addon-web-links.js"></script>
    <script src="/static/js/xterm-addon-search.js"></script>
    <script src="/static/js/socket.io.min.js"></script>

    <!-- QWebChannel for Qt integration -->
    <script type="text/javascript" src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <script>
        console.log('Script execution started');
        console.log('Terminal available:', typeof Terminal !== 'undefined');
        console.log('FitAddon available:', typeof FitAddon !== 'undefined');
        console.log('io available:', typeof io !== 'undefined');

        // Check if required libraries loaded
        if (typeof Terminal === 'undefined') {
            console.error('CRITICAL: xterm.js library failed to load from CDN');
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('loading').textContent = 'Error: Terminal library failed to load. Check internet connection.';
            throw new Error('Terminal library not loaded');
        }

        if (typeof io === 'undefined') {
            console.error('CRITICAL: socket.io library failed to load from CDN');
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('loading').textContent = 'Error: Socket.IO library failed to load. Check internet connection.';
            throw new Error('Socket.IO library not loaded');
        }

        console.log('All required libraries loaded successfully');

        // Terminal configuration
        const CONFIG = {
            cursorBlink: true,
            cursorStyle: 'block',
            scrollback: 1000,
            tabStopWidth: 4,
            fontFamily: 'Consolas, "Courier New", monospace',
            fontSize: 14,
            lineHeight: 1.2,
            letterSpacing: 0,
            theme: {
                background: '#1e1e1e',
                foreground: '#d4d4d4',
                cursor: '#ffcc00',
                cursorAccent: '#1e1e1e',
                selection: 'rgba(38, 79, 120, 0.3)',
                black: '#000000',
                red: '#cd3131',
                green: '#0dbc79',
                yellow: '#e5e510',
                blue: '#2472c8',
                magenta: '#bc3fbc',
                cyan: '#11a8cd',
                white: '#e5e5e5',
                brightBlack: '#555753',
                brightRed: '#f14c4c',
                brightGreen: '#23d18b',
                brightYellow: '#f5f543',
                brightBlue: '#3b8eea',
                brightMagenta: '#d670d6',
                brightCyan: '#29b8db',
                brightWhite: '#f5f5f5'
            }
        };

        // Initialize terminal
        const term = new Terminal(CONFIG);

        // Load addons
        const fitAddon = new FitAddon.FitAddon();
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();
        const searchAddon = new SearchAddon.SearchAddon();

        term.loadAddon(fitAddon);
        term.loadAddon(webLinksAddon);
        term.loadAddon(searchAddon);

        // Open terminal
        term.open(document.getElementById('terminal'));

        // Add DOM event listener to intercept shortcuts BEFORE xterm.js
        // This allows the events to bubble up to Qt while preventing xterm from processing them
        let bridgeReadyForShortcuts = false;
        document.getElementById('terminal').addEventListener('keydown', function(e) {
            // Debug logging
            if (e.ctrlKey && e.shiftKey) {
                console.log('DOM keydown:', e.key, 'ctrlKey:', e.ctrlKey, 'shiftKey:', e.shiftKey);
            }

            // Block pane navigation shortcuts - trigger Qt action via bridge
            if (e.ctrlKey && e.shiftKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                console.log('BLOCKING arrow key and calling Qt:', e.key);
                e.preventDefault();   // Prevent browser navigation (back/forward)
                e.stopPropagation();  // Stop xterm.js from seeing it

                // Call Qt action via bridge
                if (bridgeReadyForShortcuts && typeof terminalBridge !== 'undefined' && terminalBridge) {
                    const directionMap = {
                        'ArrowLeft': 'LEFT',
                        'ArrowRight': 'RIGHT',
                        'ArrowUp': 'UP',
                        'ArrowDown': 'DOWN'
                    };
                    terminalBridge.on_shortcut_pressed('pane.navigate_' + directionMap[e.key].toLowerCase());
                }
                return;
            }

            // Block tab navigation shortcuts
            if (e.ctrlKey && (e.key === 'PageUp' || e.key === 'PageDown')) {
                e.preventDefault();
                e.stopPropagation();
                if (bridgeReadyForShortcuts && typeof terminalBridge !== 'undefined' && terminalBridge) {
                    terminalBridge.on_shortcut_pressed('tab.navigate_' + (e.key === 'PageDown' ? 'next' : 'previous'));
                }
                return;
            }

            // Block Alt+Number shortcuts
            if (e.altKey && e.key >= '1' && e.key <= '9') {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
        }, true);  // Use capture phase to intercept before xterm.js

        // Initialize QWebChannel bridge for Qt communication
        let terminalBridge = null;

        if (typeof qt !== 'undefined') {
            new QWebChannel(qt.webChannelTransport, function(channel) {
                terminalBridge = channel.objects.terminalBridge;
                console.log('QWebChannel bridge connected');

                // Mark bridge as ready for shortcuts
                bridgeReadyForShortcuts = true;

                // Set up rich event handlers (Phase 3: Rich events)
                setupRichEventHandlers();
            });
        } else {
            console.log('QWebChannel not available (running outside Qt)');
        }

        function setupRichEventHandlers() {
            if (!terminalBridge) return;

            // Phase 3: Add xterm.js event handlers that communicate with Python

            // Selection change events
            term.onSelectionChange(() => {
                const selection = term.getSelection();
                terminalBridge.on_selection_changed(selection);
            });

            // Key press events (raw keyboard events)
            term.attachCustomKeyEventHandler((event) => {
                if (event.type === 'keydown') {
                    terminalBridge.on_key_pressed(
                        event.key,
                        event.code,
                        event.ctrlKey,
                        event.altKey,
                        event.shiftKey
                    );
                }
                return true; // Let xterm.js process the key normally (shortcuts are blocked at DOM level)
            });

            // Data events (user input)
            term.onData(data => {
                terminalBridge.on_data_received(data);
                // Continue with normal SocketIO processing
            });

            // Bell events
            term.onBell(() => {
                terminalBridge.on_bell();
            });

            // Title change events
            term.onTitleChange((title) => {
                terminalBridge.on_title_changed(title);
            });

            // Scroll events
            term.onScroll((ydisp) => {
                terminalBridge.on_scroll(ydisp);
            });

            console.log('Rich event handlers set up');
        }

        // Extract session_id from URL if present (for multi-session server)
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session_id');

        // Connect to server
        const socketOptions = {
            transports: ['websocket'],
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionAttempts: 5
        };

        // Add session_id to query for multi-session server
        if (sessionId) {
            socketOptions.query = { session_id: sessionId };
        }

        const socket = io('/pty', socketOptions);

        // Terminal input handler
        term.onData(data => {
            const payload = { input: data };
            // Include session_id for multi-session server
            if (sessionId) {
                payload.session_id = sessionId;
            }
            socket.emit('pty-input', payload);
        });

        // Server output handler
        socket.on('pty-output', data => {
            // For multi-session server, verify session_id matches
            if (!sessionId || data.session_id === sessionId) {
                term.write(data.output);
            }
        });

        // Connection handlers
        socket.on('connect', () => {
            console.log('Connected to terminal server');
            document.getElementById('loading').classList.add('hidden');

            // Fit terminal to window
            fitTerminal();

            // Send initial size
            const dims = fitAddon.proposeDimensions();
            if (dims) {
                const resizePayload = {
                    rows: dims.rows,
                    cols: dims.cols
                };
                // Include session_id for multi-session server
                if (sessionId) {
                    resizePayload.session_id = sessionId;
                }
                socket.emit('resize', resizePayload);
            }
        });

        socket.on('disconnect', reason => {
            console.log('Disconnected from terminal server:', reason);
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('loading').textContent = 'Connection lost. Reconnecting...';
        });

        socket.on('reconnect', attemptNumber => {
            console.log('Reconnected after', attemptNumber, 'attempts');
            document.getElementById('loading').classList.add('hidden');
        });

        // Handle session closed event (multi-session server)
        socket.on('session_closed', data => {
            if (!sessionId || data.session_id === sessionId) {
                console.log('Terminal session ended');
                term.write('\r\n\r\n[Process exited]\r\n');
            }
        });

        // Send heartbeat every 30 seconds (multi-session server)
        if (sessionId) {
            setInterval(() => {
                socket.emit('heartbeat', { session_id: sessionId });
            }, 30000);
        }

        // Resize handling
        function fitTerminal() {
            fitAddon.fit();
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        const resizeHandler = debounce(() => {
            fitTerminal();
            const dims = fitAddon.proposeDimensions();
            if (dims) {
                const resizePayload = {
                    rows: dims.rows,
                    cols: dims.cols
                };
                // Include session_id for multi-session server
                if (sessionId) {
                    resizePayload.session_id = sessionId;
                }
                socket.emit('resize', resizePayload);
            }
        }, 100);

        window.addEventListener('resize', resizeHandler);

        // Keyboard shortcuts
        term.attachCustomKeyEventHandler(e => {
            if (e.type !== 'keydown') return true;

            // Block tab navigation shortcuts - let Qt handle them
            // Ctrl+PgUp/PgDn are used for tab switching in the application
            if (e.ctrlKey && (e.key === 'PageUp' || e.key === 'PageDown')) {
                return false;  // Block xterm.js from processing, let Qt handle
            }

            // Block pane navigation shortcuts - let Qt handle them
            // Ctrl+Shift+Arrow keys are used for pane navigation
            if (e.ctrlKey && e.shiftKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                return false;  // Block xterm.js from processing, let Qt handle
            }

            // Block Alt+Number shortcuts for direct tab jumping
            if (e.altKey && e.key >= '1' && e.key <= '9') {
                return false;  // Block xterm.js from processing, let Qt handle
            }

            // Copy/Paste support
            if (e.ctrlKey && e.shiftKey) {
                const key = e.key.toLowerCase();

                if (key === 'c' || key === 'x') {
                    // Copy
                    const selection = term.getSelection();
                    if (selection) {
                        navigator.clipboard.writeText(selection).then(() => {
                            if (key === 'x') {
                                term.clearSelection();
                            }
                        }).catch(err => {
                            console.error('Failed to copy:', err);
                        });
                    }
                    return false;
                } else if (key === 'v') {
                    // Paste
                    navigator.clipboard.readText().then(text => {
                        if (text) {
                            socket.emit('pty-input', { input: text });
                        }
                    }).catch(err => {
                        console.error('Failed to paste:', err);
                    });
                    return false;
                } else if (key === 'f') {
                    // Search
                    const searchTerm = prompt('Search for:');
                    if (searchTerm) {
                        searchAddon.findNext(searchTerm);
                    }
                    return false;
                }
            }

            // Ctrl+L to clear
            if (e.ctrlKey && e.key === 'l') {
                term.clear();
                return false;
            }

            return true;
        });

        // Right-click context menu
        term.element.addEventListener('contextmenu', e => {
            e.preventDefault();

            // Simple context menu - you can enhance this
            const selection = term.getSelection();
            if (selection) {
                navigator.clipboard.writeText(selection);
                term.clearSelection();
            } else {
                // Paste on right-click if no selection
                navigator.clipboard.readText().then(text => {
                    if (text) {
                        socket.emit('pty-input', { input: text });
                    }
                });
            }
        });

        // Focus terminal on click
        document.addEventListener('click', () => {
            term.focus();
        });

        // Initial focus
        term.focus();

        // Expose terminal for external control
        window.terminal = term;
        window.terminalSocket = socket;
    </script>
</body>
</html>