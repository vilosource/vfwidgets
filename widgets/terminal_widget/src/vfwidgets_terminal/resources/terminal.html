<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VFWidgets Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- External dependencies -->
    <link rel="stylesheet" href="https://unpkg.com/xterm@4.19.0/css/xterm.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: monospace;
            background: #1e1e1e;
            overflow: hidden;
        }

        #terminal {
            width: 100vw;
            height: 100vh;
            padding: 4px;
        }

        /* Custom scrollbar styling */
        .xterm-viewport::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .xterm-viewport::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        .xterm-viewport::-webkit-scrollbar-thumb {
            background: #464647;
            border-radius: 5px;
        }

        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: #5a5a5c;
        }

        /* Firefox scrollbar */
        .xterm-viewport {
            scrollbar-width: thin;
            scrollbar-color: #464647 #1e1e1e;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4d4d4;
            font-size: 14px;
        }

        .loading.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>
    <div id="loading" class="loading">Connecting to terminal...</div>

    <!-- External scripts -->
    <script src="https://unpkg.com/xterm@4.19.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.5.0/lib/xterm-addon-fit.js"></script>
    <script src="https://unpkg.com/xterm-addon-web-links@0.5.0/lib/xterm-addon-web-links.js"></script>
    <script src="https://unpkg.com/xterm-addon-search@0.9.0/lib/xterm-addon-search.js"></script>
    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>

    <!-- QWebChannel for Qt integration -->
    <script type="text/javascript" src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <script>
        // Terminal configuration
        const CONFIG = {
            cursorBlink: true,
            cursorStyle: 'block',
            scrollback: 1000,
            tabStopWidth: 4,
            fontFamily: 'Consolas, "Courier New", monospace',
            fontSize: 14,
            lineHeight: 1.2,
            letterSpacing: 0,
            theme: {
                background: '#1e1e1e',
                foreground: '#d4d4d4',
                cursor: '#ffcc00',
                cursorAccent: '#1e1e1e',
                selection: 'rgba(38, 79, 120, 0.3)',
                black: '#000000',
                red: '#cd3131',
                green: '#0dbc79',
                yellow: '#e5e510',
                blue: '#2472c8',
                magenta: '#bc3fbc',
                cyan: '#11a8cd',
                white: '#e5e5e5',
                brightBlack: '#555753',
                brightRed: '#f14c4c',
                brightGreen: '#23d18b',
                brightYellow: '#f5f543',
                brightBlue: '#3b8eea',
                brightMagenta: '#d670d6',
                brightCyan: '#29b8db',
                brightWhite: '#f5f5f5'
            }
        };

        // Initialize terminal
        const term = new Terminal(CONFIG);

        // Load addons
        const fitAddon = new FitAddon.FitAddon();
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();
        const searchAddon = new SearchAddon.SearchAddon();

        term.loadAddon(fitAddon);
        term.loadAddon(webLinksAddon);
        term.loadAddon(searchAddon);

        // Open terminal
        term.open(document.getElementById('terminal'));

        // Initialize QWebChannel bridge for Qt communication
        let terminalBridge = null;

        if (typeof qt !== 'undefined') {
            new QWebChannel(qt.webChannelTransport, function(channel) {
                terminalBridge = channel.objects.terminalBridge;
                console.log('QWebChannel bridge connected');

                // Set up rich event handlers (Phase 3: Rich events)
                setupRichEventHandlers();
            });
        } else {
            console.log('QWebChannel not available (running outside Qt)');
        }

        function setupRichEventHandlers() {
            if (!terminalBridge) return;

            // Phase 3: Add xterm.js event handlers that communicate with Python

            // Selection change events
            term.onSelectionChange(() => {
                const selection = term.getSelection();
                terminalBridge.on_selection_changed(selection);
            });

            // Key press events (raw keyboard events)
            term.attachCustomKeyEventHandler((event) => {
                if (event.type === 'keydown') {
                    terminalBridge.on_key_pressed(
                        event.key,
                        event.code,
                        event.ctrlKey,
                        event.altKey,
                        event.shiftKey
                    );
                }
                return true; // Let xterm.js process the key normally
            });

            // Data events (user input)
            term.onData(data => {
                terminalBridge.on_data_received(data);
                // Continue with normal SocketIO processing
            });

            // Bell events
            term.onBell(() => {
                terminalBridge.on_bell();
            });

            // Title change events
            term.onTitleChange((title) => {
                terminalBridge.on_title_changed(title);
            });

            // Scroll events
            term.onScroll((ydisp) => {
                terminalBridge.on_scroll(ydisp);
            });

            console.log('Rich event handlers set up');
        }

        // Connect to server
        const socket = io('/pty', {
            transports: ['websocket'],
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionAttempts: 5
        });

        // Terminal input handler
        term.onData(data => {
            socket.emit('pty-input', { input: data });
        });

        // Server output handler
        socket.on('pty-output', data => {
            term.write(data.output);
        });

        // Connection handlers
        socket.on('connect', () => {
            console.log('Connected to terminal server');
            document.getElementById('loading').classList.add('hidden');

            // Fit terminal to window
            fitTerminal();

            // Send initial size
            const dims = fitAddon.proposeDimensions();
            if (dims) {
                socket.emit('resize', {
                    rows: dims.rows,
                    cols: dims.cols
                });
            }
        });

        socket.on('disconnect', reason => {
            console.log('Disconnected from terminal server:', reason);
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('loading').textContent = 'Connection lost. Reconnecting...';
        });

        socket.on('reconnect', attemptNumber => {
            console.log('Reconnected after', attemptNumber, 'attempts');
            document.getElementById('loading').classList.add('hidden');
        });

        // Resize handling
        function fitTerminal() {
            fitAddon.fit();
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        const resizeHandler = debounce(() => {
            fitTerminal();
            const dims = fitAddon.proposeDimensions();
            if (dims) {
                socket.emit('resize', {
                    rows: dims.rows,
                    cols: dims.cols
                });
            }
        }, 100);

        window.addEventListener('resize', resizeHandler);

        // Keyboard shortcuts
        term.attachCustomKeyEventHandler(e => {
            if (e.type !== 'keydown') return true;

            // Copy/Paste support
            if (e.ctrlKey && e.shiftKey) {
                const key = e.key.toLowerCase();

                if (key === 'c' || key === 'x') {
                    // Copy
                    const selection = term.getSelection();
                    if (selection) {
                        navigator.clipboard.writeText(selection).then(() => {
                            if (key === 'x') {
                                term.clearSelection();
                            }
                        }).catch(err => {
                            console.error('Failed to copy:', err);
                        });
                    }
                    return false;
                } else if (key === 'v') {
                    // Paste
                    navigator.clipboard.readText().then(text => {
                        if (text) {
                            socket.emit('pty-input', { input: text });
                        }
                    }).catch(err => {
                        console.error('Failed to paste:', err);
                    });
                    return false;
                } else if (key === 'f') {
                    // Search
                    const searchTerm = prompt('Search for:');
                    if (searchTerm) {
                        searchAddon.findNext(searchTerm);
                    }
                    return false;
                }
            }

            // Ctrl+L to clear
            if (e.ctrlKey && e.key === 'l') {
                term.clear();
                return false;
            }

            return true;
        });

        // Right-click context menu
        term.element.addEventListener('contextmenu', e => {
            e.preventDefault();

            // Simple context menu - you can enhance this
            const selection = term.getSelection();
            if (selection) {
                navigator.clipboard.writeText(selection);
                term.clearSelection();
            } else {
                // Paste on right-click if no selection
                navigator.clipboard.readText().then(text => {
                    if (text) {
                        socket.emit('pty-input', { input: text });
                    }
                });
            }
        });

        // Focus terminal on click
        document.addEventListener('click', () => {
            term.focus();
        });

        // Initial focus
        term.focus();

        // Expose terminal for external control
        window.terminal = term;
        window.terminalSocket = socket;
    </script>
</body>
</html>